def my_function(a, b, c):
  print(a + b + c)

# Decorate my_function() with the print_args() decorator
my_function = print_args(my_function)

my_function(1, 2, 3)

my_function was called with a=1, b=2, c=3
6

-------------------

# Decorate my_function() with the print_args() decorator
@print_args
def my_function(a, b, c):
  print(a + b + c)

my_function(1, 2, 3)

my_function was called with a=1, b=2, c=3
6

What a delightful decorator! Note that @print_args before the definition of my_function is exactly equivalent to my_function = print_args(my_function). 
Remember, even though decorators are functions themselves, when you use decorator syntax with the @ symbol you do not include the parentheses after 
the decorator name.
-----------

def print_before_and_after(func):
  def wrapper(*args):
    print('Before {}'.format(func.__name__))
    # Call the function being decorated with *args
    func(*args)
    print('After {}'.format(func.__name__))
  # Return the nested function
  return wrapper

@print_before_and_after
def multiply(a, b):
  print(a * b)

multiply(5, 10)


Before multiply
50
After multiply
---------

